<!DOCTYPE html> <html lang="en"> 	 	<body> 		<div style="display: flex; flex: 1">  			<!-- Main Content --> 			<main> 				<h2>Database Operations</h2> 				<p> 					Database operations encapsulate interactions with a data source. This 					includes querying, batch processing, and managing transactions to 					ensure atomicity. Operations simplify the complexity of working with 					databases, enabling safe, efficient, and reusable data manipulations. 				</p>  				<h3>Core Interfaces and Classes</h3> 				<ul> 					<li> 						<strong>AtomicOperation:</strong> Represents a single, encapsulated 						database operation. This interface ensures that the operation can be 						executed safely within a managed transaction. 					</li> 					<li> 						<strong>Query:</strong> Encapsulates a SQL query for execution 						against a database. Provides a way to parameterize and reuse 						queries. 					</li> 					<li> 						<strong>QueryOperation:</strong> Executes a single query as an 						atomic operation. Parameters are bound to ensure safe execution. 					</li> 					<li> 						<strong>TransactionOperation:</strong> Groups multiple atomic 						operations into a single transaction. Guarantees that either all 						operations succeed, or none are applied. 					</li> 					<li> 						<strong>BatchOperation:</strong> Facilitates bulk operations by 						batching multiple records into a single query for improved 						performance. 					</li> 				</ul>  				<h3>AtomicOperation Interface</h3> 				<p> 					The <code>AtomicOperation</code> interface defines a standard way to 					encapsulate database operations, ensuring proper lifecycle management 					and transaction safety. 				</p>  				<h4>Key Methods</h4> 				<ul> 					<li> 						<code>void execute(Connection connection):</code> Executes the 						operation using the provided database connection. 					</li> 				</ul>  				<h2>Example: Custom AtomicOperation</h2> 				<p> 					A custom implementation of the <code>AtomicOperation</code> interface 					that logs each record in a table to an external system. 				</p>  				<pre><code class="language-java"> /**   * A custom implementation of the AtomicOperation interface that logs each record in a table to an external system.   */ public class LoggingOperation implements AtomicOperation {     private Query query; // The query to fetch the records.     private Logger logger; // The logging system to use.      /**       * Constructor to initialize the query and logger.       *       * @param query The query to execute.       * @param logger The logger for recording entries.       */     public LoggingOperation(Query query, Logger logger)     {         this.query = query;         this.logger = logger;     }      /**       * Executes the logging operation within a transaction.       *       * @param connection The database connection to use.       * @throws SQLException If a database error occurs.       */     @Override     public void execute(Connection connection) throws SQLException     {         JSONObject record;         ResultSetMetaData metaData;          // Prepare the statement and execute the query         try (PreparedStatement statement = connection.prepareStatement(query.toString());               ResultSet resultSet = statement.executeQuery())               {              while (resultSet.next()) {                 record = new JSONObject();                 metaData = resultSet.getMetaData();                  for (int i = 1; i <= metaData.getColumnCount(); i++)                 {                     record.put(metaData.getColumnName(i), resultSet.getObject(i));                 }                  logger.log(record.toString());             }         }     } } </code></pre>  				<h3>TransactionOperation</h3> 				<p> 					The <code>TransactionOperation</code> class allows multiple 					<code>AtomicOperation</code> instances to be executed as a single 					transaction, ensuring atomicity. 				</p>  				<h4>Key Features</h4> 				<ul> 					<li> 						Groups multiple operations for execution within a transaction. 					</li> 					<li> 						Handles rollback in case of failure, maintaining database 						consistency. 					</li> 				</ul>  				<h4>Usage Example</h4> 				<pre><code> public void transactionOperation() {     DBMS database = new DBMS(source);      QueryOperation insertCustomer = new QueryOperation(new Query("INSERT INTO CUSTOMER (id, name) VALUES (1, 'Alice')"));     QueryOperation updateAccount = new QueryOperation(new Query("UPDATE ACCOUNT SET balance = balance - 100 WHERE id = 1"));      TransactionOperation transaction = new TransactionOperation(List.of(insertCustomer, updateAccount));     database.execute(transaction); }         </code></pre>  				<h3>BatchOperation</h3> 				<p> 					The <code>BatchOperation</code> class is designed for executing bulk 					queries efficiently. It reduces overhead by batching multiple records 					into a single operation. 				</p>  				<h4>Key Features</h4> 				<ul> 					<li> 						Executes multiple inserts, updates, or deletes in a single query. 					</li> 					<li> 						Supports setting a commit size for better control over batch 						transactions. 					</li> 				</ul>  				<h4>Usage Example</h4> 				<pre><code> public void batchOperation() {     Query query = new Query("INSERT INTO CUSTOMER (id, name, age) VALUES (?, ?, ?)");     List&lt;JSONObject&gt; records = List.of(         new JSONObject().put("id", 1).put("name", "Alice").put("age", 30),         new JSONObject().put("id", 2).put("name", "Bob").put("age", 25)     );      BatchOperation batch = new BatchOperation(query, records);     batch.setCommit(50); // Commit after every 50 records      DBMS dbms = new DBMS(source);     dbms.execute(batch); }         </code></pre>  				<h3>Query Class</h3> 				<p> 					The <code>Query</code> class encapsulates a SQL query for execution. 					It allows parameterized queries and ensures safe binding of values. 				</p>  				<h4>Example Usage</h4> 				<pre><code> public void queryOperation() {     Query query = new Query("SELECT * FROM CUSTOMER WHERE id = ?");     query.setParameter(1, 12345);      DBMS dbms = new DBMS(source);     Iterable&lt;JSONObject&gt; results = dbms.query(query);      for (JSONObject record : results)     {         System.out.println(record);     } }         </code></pre>  				<h3>Best Practices</h3> 				<ul> 					<li> 						Use <code>TransactionOperation</code> for critical workflows that 						involve multiple steps to ensure consistency. 					</li> 					<li> 						Leverage <code>BatchOperation</code> for large-scale data processing 						to optimize performance. 					</li> 					<li> 						Always validate query parameters to prevent SQL injection and ensure 						data integrity. 					</li> 				</ul> 			</main> 		</div> 	</body> </html> 